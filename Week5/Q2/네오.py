"""
참 애매한 문제였습니다.
완전탐색을 하자니 시간초과가 날 게 뻔하고
dp를 적용하기엔 좋은 문제가 아니었습니다.
그러다 x라는 수가 n 제곱이 되면서 합이 s가 되면
그게 최고의 집합이 아닐까 생각해보았습니다.
왜냐하면 어차피 합은 s가 되어야 하므로 수의 조합이 어떻게 될지는 중요한 게 아닙니다.
중복조합의 합은 s로, 개수는 n으로 정해져 있으므로 평균은 중요하지 않습니다.
문제는 어떻게 분포가 되어 있느냐인데,
수들의 곱을 최대화하려면 다음과 같은 가정을 따릅니다.

예를 들어 어떤 x가 있다고 할 때
{x, x}와 {x-n, x+n}의 합은 같습니다.
(x-n) * (x+n) = x^2 -2nx + n^2 인데
이 식을 최대화하려면
n(n - 2x)가 최대가 되어야 하는데,
2x가 0 이상이기 때문에(x는 자연수) 최종적으로는 0 이하일 수 밖에 없습니다.
즉 어떤 중복 집합의 합이 같을 때
두 수의 곱이 최대가 되는 방법은 그 수를 최대한 균일하게 나누는 것입니다.
따라서 s를 n으로 나눈 수를 n번 배치한 후 맨 마지막에서 나머지 만큼의 수들에 1을 더해주면 됩니다.
"""


def solution(n, s):
    x = s // n

    if x == 0:
        return [-1]

    answer = [x] * n
    rest = s % n

    for i in range(-rest, 0, 1):
        answer[i] += 1

    return answer